#!/usr/bin/env groovy
/**
 * Integration Tests Pipeline for uniteDiscord
 * Runs integration tests with database setup
 */


pipeline {
    agent {
        node {
            label 'integration'
        }
    }

    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '30'))
        timeout(time: 45, unit: 'MINUTES')
    }

    environment {
        CI = 'true'
        NODE_ENV = 'test'
        GITHUB_OWNER = 'steiner385'
        GITHUB_REPO = 'uniteDiscord'
        // Database URL for test container
        DATABASE_URL = 'postgresql://test:test@localhost:5433/unite_discord_test'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                }
                echo "Running integration tests for commit: ${env.GIT_COMMIT_SHORT}"
            }
        }

        stage('Install Dependencies') {
            steps {
                sh '''
                    rm -f .npmrc
                    npm config set registry https://registry.npmjs.org

                    # Install pnpm if not available
                    if ! command -v pnpm &> /dev/null; then
                        npm install -g pnpm@9
                    fi

                    # Install dependencies
                    pnpm install --frozen-lockfile || pnpm install
                '''
            }
        }

        stage('Start Test Infrastructure') {
            steps {
                sh '''
                    echo "Starting test infrastructure..."
                    docker compose -f docker-compose.test.yml up -d --wait || docker compose -f docker-compose.test.yml up -d

                    # Wait for PostgreSQL to be ready
                    echo "Waiting for PostgreSQL..."
                    for i in $(seq 1 30); do
                        if docker exec unite-discord-postgres-test pg_isready -U test -d unite_discord_test 2>/dev/null; then
                            echo "PostgreSQL is ready"
                            break
                        fi
                        echo "Waiting for PostgreSQL... attempt $i/30"
                        sleep 2
                    done

                    # Wait for Redis
                    echo "Waiting for Redis..."
                    for i in $(seq 1 15); do
                        if docker exec unite-discord-redis-test redis-cli ping 2>/dev/null | grep -q PONG; then
                            echo "Redis is ready"
                            break
                        fi
                        echo "Waiting for Redis... attempt $i/15"
                        sleep 2
                    done

                    echo "Test infrastructure is ready!"
                '''
            }
        }

        stage('Database Setup') {
            steps {
                sh '''
                    echo "Running database migrations..."
                    cd packages/db-models
                    npx prisma migrate deploy || npx prisma db push --accept-data-loss

                    echo "Generating Prisma client..."
                    npx prisma generate
                '''
            }
        }

        stage('Clear Test Artifacts') {
            steps {
                sh 'rm -rf allure-results test-results coverage'
            }
        }

        stage('Integration Tests') {
            steps {
                script {
                    def testResult = sh(
                        script: '''#!/bin/bash
                            set -o pipefail
                            pnpm run test:integration 2>&1 | tee test-output.log
                        ''',
                        returnStatus: true
                    )
                    env.TEST_EXIT_CODE = testResult.toString()

                    if (testResult != 0) {
                        error("Integration tests failed with exit code ${testResult}")
                    }
                }
            }
            post {
                always {
                    // Publish JUnit results if available
                    junit allowEmptyResults: true, testResults: '**/coverage/integration-junit.xml'

                    script {
                        if (fileExists('allure-results')) {
                            allure([
                                includeProperties: true,
                                jdk: '',
                                results: [[path: 'allure-results']],
                                reportBuildPolicy: 'ALWAYS'
                            ])
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                // Collect test execution metrics
                sh '''
                    mkdir -p reports/metrics
                    echo "üìä Integration tests completed"
                '''
            }

            // Stop test infrastructure
            sh '''
                echo "Stopping test infrastructure..."
                docker compose -f docker-compose.test.yml down -v || true
            '''

            // Archive metrics
            archiveArtifacts artifacts: 'reports/metrics/**', allowEmptyArchive: true
            archiveArtifacts artifacts: 'test-output.log', allowEmptyArchive: true
        }
        success {
            echo '‚úÖ Integration tests passed!'
        }
        failure {
            echo '‚ùå Integration tests failed - check logs for details'
        }
    }
}
